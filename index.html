<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Big Bubble!</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                background:#000;
                padding:0;
                margin:0;
                font-weight: bold;
                overflow:hidden;
            }

            #game {
                margin:20px auto 40px;
                border:1px solid #fff;
            }
            a {    color: #ffffff;    }

            #oldie a { color:#0b0 }
        </style>
    </head>

    <body>
<div id="game"></div>
<div id="vshader">

          varying vec2 vUv;
          varying float posz;
          varying float posy;
          varying float posx;

          void main() {
              vUv = uv;
              posx = position.x;
              posy = position.y;
              posz = position.z;
              vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
              gl_Position = projectionMatrix * mvPosition;
          }

      </div>
      <div id="fshader">

uniform vec2 resolution;
uniform float time;
uniform float beamSpeed;
uniform int numBeams;
uniform float brightness;

#define PI 3.1416

vec3 dir(vec3 pos, float rotation) {
    return vec3(800,100,0);
}

//some ugly clouds
//noise function lifted from that eye
//added modification so I have 3d noise
//needs more light scattering and god rays

#ifdef GL_ES
precision mediump float;
#endif

mat2 m = mat2( 0.90,  0.110, -0.70,  1.00 );

float hash( float n )
{
    return fract(sin(n)*758.5453);
}

float noise( in vec3 x )
{
    vec3 p = floor(x);
    vec3 f = fract(x);
    //f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0 + p.z*800.0;
    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);
    return res;
}

float fbm( vec3 p )
{
    float f = 0.0;
    f += 0.50000*noise( p ); p = p*2.02;
    f += 0.25000*noise( p ); p = p*2.03;
    f += 0.12500*noise( p ); p = p*2.01;
    f += 0.06250*noise( p ); p = p*2.04;
    f += 0.03125*noise( p );
    return f/0.984375;
}

float cloud(vec3 p)
{
    float a =0.0;
    a+=fbm(p*3.0)*2.2-0.9;
    if (a<0.0) a=0.0;
    //a=a*a;
    return a;
}

vec3 f2(vec3 c)
{
    c+=hash(time+gl_FragCoord.x+gl_FragCoord.y*9.9)*0.01;
    
    
    c*=0.7-length(gl_FragCoord.xy / resolution.xy -0.5)*0.3;
    float w=length(c);
    c=mix(c*vec3(1.0,1.2,1.6),vec3(w,w,w)*vec3(1.4,1.2,1.0),w*1.1-0.2);
    return c;
}


bool leftToRight = false;
float slopeSign = (leftToRight ? -1.0 : 1.0);
float slope1 = 5.0 * slopeSign;
float slope2 = 7.0 * slopeSign;

void main(void) {
    vec2 p = (gl_FragCoord.xy) / resolution.xy;
    p.x += 0.0;
    p.y -= 0.6;
    vec2 center = vec2(0.5, 0.5);
    float d = distance(p, center);
        
    // bluish tint from top left
    vec3 color = vec3(1.0 - d * 0.75) * vec3(0.03, 0.35, 1.0);
    
    // add some green near centre
    color += (1.0-distance(p, vec2(1.0, 1.0))*1.) * 0.5 * vec3(0.35, 0.65, 0.45);
    
    vec3 lightColor = vec3(0.1, 0.35, 0.65);
    
    // will be better as uniforms
    for (int i=0; i < numBeams; i++) {
        // direction of light
        float zr = sin(time * beamSpeed * float(i)) * 0.5 - PI/3.0;
        vec3 dir = vec3(cos(zr), sin(zr), 0.0);
        
        p.x += 0.14;
        
        // normalized spotlight vector
        vec3 SpotDir = normalize(dir);
        
        vec3 attenuation = vec3(0.5, 7.0, 10.0);
        float shadow = brightness / (attenuation.x + (attenuation.y * d) + (attenuation.z * d * d));

        vec3 pos = vec3(p, 0.0);
        vec3 delta = normalize(pos - vec3(center, 0.0));
        
        float cosOuterCone = cos(radians(1.0));
        float cosInnerCone = cos(radians(15.0 + float(i * 2)));
        float cosDirection = dot(delta, SpotDir);
        
        // light...
        color += smoothstep(cosInnerCone, cosOuterCone, cosDirection) * shadow * lightColor;
    }
    color += sin(time * 0.5) * 0.05;
    gl_FragColor = vec4(vec3(color), 1.0);


//    vec2 distanceVector = gl_FragCoord.xy - (vec2(0.5, 1.0) * resolution);
//    float angle = atan(distanceVector.x, distanceVector.y) + time * .5 * (1. - 0.0001 * length(distanceVector));
//    float isSolid = clamp(cos(angle*16.0 + 2. * sin(time * 5. - length(distanceVector) * 0.05)) * 100.0, 0.95, 1.0);
//    gl_FragColor = vec4(144.0/255.0, 8.0/255.0, 78.0/255.0, 1.0) * isSolid * vec4(vec3(color), 1.0);









    
    
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    float bright =
        - sin(uv.y * slope1 + uv.x * 30.0+ time *2.10) *.2
        - sin(uv.y * slope2 + uv.x * 37.0 + time *2.10) *.1
        - cos(              + uv.x * 2.0 * slopeSign + time * 1.10) *.1
        - sin(              - uv.x * 5.0 * slopeSign + time * 1.0) * .3;
    
    float modulate = abs(cos(time * .1) * 0.1 + sin(time * .7)) * 1.5;
    bright *= modulate;
    vec4 pix = vec4(0.5, 0.5, 0.5, 1.0);
    pix += clamp(bright / 1.0,0.0,1.0);

    gl_FragColor = vec4(vec3(color), 1.0) + ( 0.1 * pix ) ;


}

  
</div>


        <script src="js/three.min.js"></script>
        <script src="js/jquery-2.0.0.min.js"></script>
        <script src="js/mousetrap.min.js"></script>
        <script src="js/FresnelShader.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/bubble.js"></script>
    </body>
</html>
